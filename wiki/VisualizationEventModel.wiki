#summary Exposing the visualization event model in your visualization wrapper

= Exposing Events =

Many visualizations support events, meaning that the caller of the visualization can add event handlers to the visualization object to handle user actions.  If you are wrapping a visualization that generates events, you need to expose those events in your GWT wrapper.

= The Select Event =

Many visualizations support the "select event", an event generated when the user selects an aspect of the visualization.  So the GWT Visualization API includes special support for the select event.  The wrapper for a visualization that supports selection should implement the Selectable interface, and use the SelectionHelper class to implement three special methods:

{{{
  public final void addSelectHandler(SelectHandler handler) {
    SelectionHelper.addSelectHandler(this, handler);
  }

  public final Selection getSelection() {
    return SelectionHelper.getSelection(this);
  }

  public final void setSelection(Selection sel) {
    SelectionHelper.setSelection(this, sel);
  }
}}}

For a visualization that supports selection, that's all you need to do.  Let's see what you need to do when the visualization that you are wrapping supports other events.

= The Handler Class and its Subclasses =

To support an event, you need to write a class to wrap the event.  The event handler class should extend the base class Handler.  Here is a simple example:

{{{
/* Copyright 2008 Google Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.gwt.visualization.client.events;

import com.google.gwt.visualization.client.Properties;

/**
 * This class handles page events for visualizations such as Table.
 */
public abstract class PageHandler extends Handler {
  /**
   * This event is fired when the user clicks a button to change the 
   * current page on the visualization, such as "next" or "back".
   */
  public class PageEvent {
    private int page;
    public PageEvent(int page) { this.page = page; }
    public int getPage() { return page; }
  }
  
  public abstract void onPage(PageEvent event);
  
  @Override
  protected void onEvent(Properties properties) {
    // extract the event properties from the "properties" object by name
    int page = properties.getInt("page");

    // construct an event object with the data extracted from the "properties" object
    PageEvent event = new PageEvent(page);

    // call the public abstract "on event" method with the event object
    onPage(event);
  }
}
}}}

== The Event Class ==

The event handler class should include an inner class with fields matching the properties of the event.  (The "event" class does not strictly need to be an inner class, but that is the convention in the GWT Visualization API.)  The event class should be a "bean" class, in other words, a simple data structure with methods for accessing the data.  Here is an example of an event with a single property, an integer value called "page":

{{{
  public class PageEvent {
    private int page;
    public PageEvent(int page) { this.page = page; }
    public int getPage() { return page; }
  }
}}}

An event with more properties would have more fields.

== The Event Callback ==

The event handler class should declare an abstract method for callers to override.  This "callback" method should take a single parameter of the inner event class discussed above.  For example:

{{{
  public abstract void onPage(PageEvent event);
}}}

== Implementing the onEvent Method ==

The event handler class must override the method Handler.onEvent().  onEvent is called when the event is fired.  The idea of the onEvent method is to convert a Properties object, which is an "untyped" map of Strings to values, into the fully typed event data structure.  The implementation of onEvent() should extract the event properties from the Properties object, construct an event object with the event properties, and call an "on event" method with the event object.  For example:

{{{
  @Override
  protected void onEvent(Properties properties) {
    // extract the event properties from the "properties" object by name
    int page = properties.getInt("page");

    // construct an event object with the data extracted from the "properties" object
    PageEvent event = new PageEvent(page);

    // call the public abstract "on event" method with the event object
    onPage(event);
  }
}}}

= The addHandler() Method =

Strictly speaking, you're done: you don't actually need to touch the visualization wrapper at all.  However, it is good practice to add an addHandler() method to the visualization wrapper.  This method should simply delegate to Handler.addHandler():

{{{
  public final void addPageListener(PageHandler listener) {
    Handler.addHandler(this, "page", listener);
  }
}}}